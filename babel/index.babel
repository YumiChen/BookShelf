// add callback when page is changed
let index = 1;
const { Router, Route, Link, Switch, BrowserRouter, HashRouter } = ReactRouterDOM,
      {Component} = React,
      { render } = ReactDOM,
      { CSSTransitionGroup } = React.addons,
      thunk = ReduxThunk.default;

/*--Reducers--*/
const reducer_searched_books = (state=[],action)=>{
  if(action.type=="SEARCH" && Object.prototype.toString.call( action.payload ) === '[object Array]'){
    return  action.payload || state;
  }else if(action.type=="SEARCHMORE" && Object.prototype.toString.call( action.payload )){
    let result = state;
    result = result.concat(action.payload);
    return result;
  }else{
    // return []?
    return state;
  }
}
// loadStore("readingBooks")|[]
// console.log("localstore: "+loadStore("readingBooks"));

// state=loadStore("readingBooks")===0?[]:loadStore("readingBooks")
const reducer_reading_books = (state=loadStore("readingBooks")===0?[]:loadStore("readingBooks"),
  action)=>{
  // console.log("readingBooks: "+state);

  let books = state;
  switch(action.type){
    case "ADDREADING":
      books.unshift(action.payload);
      sweetAlert("Success!", "The book is added!", "success");
      return books;
    case "REMOVEREADING":
      books.splice(action.payload,1);
      return books;
    default:
      return state
  }
}
// state=loadStore("finishedBooks")===0?[]:loadStore("finishedBooks") 
const reducer_finished_books = (state=loadStore("finishedBooks")===0?[]:loadStore("finishedBooks"),action)=>{
  let books = state;
  // save();
  switch(action.type){
    case "ADDFINISHED":
      books.unshift(action.payload);
      sweetAlert("Success!", "The book is added!", "success");
      return books;
    case "REMOVEFINISHED":
      books.splice(action.payload,1);
      return books;
    default:
      return state;
  }
}

// state=loadStore("wannaReadBooks")===0?[]:loadStore("wannaReadBooks") 
const reducer_wanna_read_books = (state=loadStore("wannaReadBooks")===0?[]:loadStore("wannaReadBooks"),action)=>{
  let books = state;
  switch(action.type){
    case "ADDWANNAREAD":
      books.unshift(action.payload);
      sweetAlert("Success!", "The book is added!", "success");
      return books;
    case "REMOVEWANNAREAD":
      books.splice(action.payload,1);
      return books;
    default:
      return state;
  }
}

const reducer_searched_term = (state="art",action)=>{
  return action.payload || state;
}

const reducer_currentBook = (state={},action)=>{
  if(action.type=="SELECT")
    return  action.payload || state;
  else
    return state;
}


const rootReducer = Redux.combineReducers({
  searchedBooks: reducer_searched_books,
  searchedTerm: reducer_searched_term,
  readingBooks: reducer_reading_books,
  finishedBooks: reducer_finished_books,
  wannaReadBooks: reducer_wanna_read_books,
  currentBook: reducer_currentBook
});

/*--Action creators--*/
const action_searchedTerm = (event)=>{
  let term = event.target.value;
  return {
    type: "SEARCH",
    payload: term
  };
}

// query books with google books api
const action_searchedBooks = ()=>{
  // const term = store.getState().searchedTerm, 
  const term = document.getElementById("searchInput").value, 
        fetch = window.fetch("https://www.googleapis.com/books/v1/volumes?q="+term+"&maxResults=30");

  return (dispatch)=>{
    fetch.then((data)=>{
        return data.json();
      }).then(({items})=>{
        dispatch({
        type: "SEARCH",
        payload: items
        });
      })
      // .catch(err,()=>{alert(err)});
  };
}

// query books with google books api
const action_searchMoreBooks = (index)=>{
  // const term = store.getState().searchedTerm, 
  const term = document.getElementById("searchInput").value, 
        fetch = window.fetch("https://www.googleapis.com/books/v1/volumes?q="+term+"&maxResults=30"+"&startIndex="+index);

  return (dispatch)=>{
    fetch.then((data)=>{
        return data.json();
      }).then(({items})=>{
        dispatch({
        type: "SEARCHMORE",
        payload: items
        });
      })
      // .catch(err,()=>{alert(err)});
  };
}

// select book to show details
const action_selectBook = (event)=>{
  window.scrollTo(0,0);
  const id =event.target.getAttribute("name"),
        group = event.target.getAttribute("data-group");
  // accessing other state...
  switch(group){
    case "searched":
      return ({
        type: "SELECT",
        payload: store.getState().searchedBooks[id]
  });
    case "reading":
      return ({
        type: "SELECT",
        payload: store.getState().readingBooks[id]
  });
    case "finished":
      return ({
        type: "SELECT",
        payload: store.getState().finishedBooks[id]
  });
    case "wannaRead":
      return ({
        type: "SELECT",
        payload: store.getState().wannaReadBooks[id]
  });
    default:
  }
  
}

// adding data
const action_addReadingBooks = (event)=>{
  const group = event.target.getAttribute("data-group"),
 id=event.target.getAttribute("name");
  switch(group){
      case "current": 
  const currentBook=store.getState().currentBook;
  return {type:"ADDREADING",
          payload:currentBook
         };
      case "reading":
         return {
           type: "ADDREADING",
           payload: store.getState().readingBooks[id]
         };
      case "finished":
          return {
           type: "ADDREADING",
           payload: store.getState().finishedBooks[id]
         };
      case "wannaRead": 
          return {
           type: "ADDREADING",
           payload: store.getState().wannaReadBooks[id]
         };
  }
}

const action_addFinishedBooks = (event)=>{
  const group = event.target.getAttribute("data-group"),   id=event.target.getAttribute("name");
  switch(group){
      case "current": 
  const currentBook=store.getState().currentBook;
  return {type:"ADDFINISHED",
          payload:currentBook
         };
      case "reading":
         return {
           type: "ADDFINISHED",
           payload: store.getState().readingBooks[id]
         };
      case "finished":
          return {
           type: "ADDFINISHED",
           payload: store.getState().finishedBooks[id]
         };
      case "wannaRead": 
          return {
           type: "ADDFINISHED",
           payload: store.getState().wannaReadBooks[id]
         };
  }
}

const action_addWannaReadBooks = (event)=>{
  const group = event.target.getAttribute("data-group"), id=event.target.getAttribute("name");
  switch(group){
      case "current": 
       const currentBook=store.getState().currentBook;
  return {type:"ADDWANNAREAD",
          payload:currentBook
         };
      case "reading":
         return {
           type: "ADDWANNAREAD",
           payload: store.getState().readingBooks[id]
         };
      case "finished":
          return {
           type: "ADDWANNAREAD",
           payload: store.getState().finishedBooks[id]
         };
      case "wannaRead": 
          return {
           type: "ADDWANNAREAD",
           payload: store.getState().wannaReadBooks[id]
         };
  }
  
}

// remove data
const action_removeBooks = (event)=>{
  const group = event.target.getAttribute("data-group"),
        id=event.target.getAttribute("name");
  switch(group){
  case "reading":
  return {
            type:"REMOVEREADING",
            payload: id
          };
  case "finished":
          return {
            type:"REMOVEFINISHED",
            payload: id
          };
  case "wannaRead":
          return {
            type:"REMOVEWANNAREAD",
            payload: id
          };
  }
}




/*--Components & containers--*/
class ShelfPage extends Component{
  constructor(props){
    super(props);
  }
  componentDidMount(){
  }
  render(){
    return (<div className="shelfPage">
        <div>
        <span className="shelfName">Reading</span>
        <Shelf books={this.props.readingBooks} group="reading"
          endpoint="reading/"/>
        </div>
        <div>
        <span className="shelfName">Finished</span>
        <Shelf 
          books={this.props.finishedBooks}     group="finished"
          endpoint="finished/"/>
        </div>
        <div>
        <span className="shelfName">Wishlist</span>
        <Shelf books={this.props.wannaReadBooks} group="wannaRead"
          endpoint="wannaRead/"/>
      </div></div>);
  }
}

const ShelfPage_mapStateToProps=(state)=>{
  return {
          readingBooks: state.readingBooks,
          finishedBooks: state.finishedBooks,
          wannaReadBooks: state.wannaReadBooks
         };
}

ShelfPage = ReactRedux.connect(ShelfPage_mapStateToProps,null)(ShelfPage);


let Shelf =(props)=>{
  const settings = {
      dots: false,
      infinite: false,
      speed: 500,
      slidesToShow: 5,
      slidesToScroll: 5
    };
  var isPortrait = (window.innerWidth<(window.innerHeight/1.5));
  if(isPortrait){
      settings.slidesToShow = 2;
      settings.slidesToScroll = 2;
  }
  let books = []; 
    if( Object.prototype.toString.call( props.books ) === '[object Array]'){ 
      books = props.books.map((book,index)=>{ 
  return (<div><Book 
                 key={index} 
                 name={index} 
                 data-index={index} 
                 info={book}
                 group={props.group}
                 settings={true}
                 endpoint={props.endpoint}
                 onClick={props.select}
            /></div>);   
    });                                       
  }
  
  return (
      <div className="slider">
      <Slider {...settings}>
        {books}
      </Slider>
      </div>);
}
// {books==[]?books:<p>There's no book here</p>}

// get searched term from search bar
class SearchPage extends Component{
  constructor(props){
    super(props);
    // this.state = {index: 1, phase:"NOTSEARCHED"};
  }
  componentWillMount(){
    window.onscroll = (function(ev) {
    if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight) {
      this.searchMore();
      }
    }).bind(this);
  }
  componentWillUnmount(){
    window.onscroll = null;
  }
  componentWillReceiveProps(){
    // this.setState({phase: "SEARCHING"});
    // alert("receive props");
  }
  componentDidUpdate(){
    // this.setState({phase: "SEARCHED"});
    // alert("Did receive props");
  }
  searchMore(){
    // this.setState({index: index += 30});
    this.props.searchMore(index+=30);
  }
  render(){
    this.searchMore = this.searchMore.bind(this);
    let books = [];
      books = this.props.searchedBooks.map((book,index)=>{
  return <Book key={index} name={index} info={book} group="searched" endpoint=""/>;
    });                                       
    
  return (
    <div>
      <SearchBar/>
        <div className="searchedBooks" >
 {books.length===0&&this.phase=="SEARCHED"?<p>
          無搜尋結果
          </p>:null}
          {books}
        
        </div>
    </div>
  );
  }
}
// !books===[]?books:<p className="hint">No book here right now.</p>

const SearchPage_mapStateToProps=(state)=>{
  return {searchedBooks: state.searchedBooks};
}

const SearchPage_mapDispatchToProps = (dispatch)=>{
  return Redux.bindActionCreators({
    searchMore: action_searchMoreBooks
    },dispatch);
}

SearchPage = 
ReactRedux.connect(SearchPage_mapStateToProps,SearchPage_mapDispatchToProps)(SearchPage);

let SearchBar = (props)=>{
  return (<div >
      <p className = "searchBar">
      <i className="fa fa-search" aria-hidden="true"/>
      <form onSubmit={(event)=>{
            event.preventDefault();                       index = 1;
            props.search();}}>
      <input type="text" id="searchInput" placeholder="Find your next favorote..."/>
      <input type="submit" value="SEND"/>
      </form>
      </p>
      </div>);
}
// onChange={props.changeTerm}
// onChange={debounce(props.search,900)}
// value={props.searchedTerm}

// const SearchPage_mapStateToProps_searchedTerm=(state)=>{
//   return {searchedTerm: state.searchedTerm};
// }

const mapDispatchToProps_searchedTerm = (dispatch)=>{
  return Redux.bindActionCreators({
    search: action_searchedBooks,
    changeTerm: action_searchedTerm},dispatch);
}

SearchBar = ReactRedux.connect(null,mapDispatchToProps_searchedTerm)(SearchBar);

class Book extends Component{
  constructor(props){
    super(props);
  }
  render(){
  const props = this.props,
        info = props.info.volumeInfo,
      isbn = info.industryIdentifiers?info.industryIdentifiers[0].identifier:"-1",
  cover = info.imageLinks?{
  backgroundImage: 'url(' + info.imageLinks.smallThumbnail + ')'
}:null,     group=props.group,name=props.name,
      title=info.title,
      isPortrait = (window.innerWidth<window.innerHeight);

 let author=info.authors;
    author = author?author.toString():"";
  return (
     <div className="book" name={name} data-group={group}>
      { props.settings?<Settings
 group={group} name={name}/>:"" }
    <Link to={"/"+props.endpoint+isbn} onClick={props.select} name={name} data-group={group}>
      <div className="cover" style={cover} name={name} data-group={group}></div>
      {props.settings?"":<div className="bookdes">
        <p name={name} data-group={group}>{title?(title.length>20?title.substring(0,20)+"...":title):null}</p>
        <p name={name} data-group={group}>{author?(author.length>20?author.substring(0,20)+"...":author):null}</p></div>}
    </Link>
    </div>
  );
  }
}
// &&isPortrait

const mapDispatchToProps_selectBook = (dispatch)=>{
  return Redux.bindActionCreators({select: action_selectBook},dispatch);
}

Book = ReactRedux.connect(null,mapDispatchToProps_selectBook)(Book);

class Settings extends Component{
constructor(props){
  super(props);
  this.state={showDrop:false};
}
showDrop(){
  this.setState({showDrop:!this.state.showDrop});
}
updateReadingBooks(event){
this.props.addReadingBooks(event);
  this.props.removeBooks(event);
  document.getElementsByClassName('title')[0].click();
  // this.forceUpdate();
  // promptAlert("Confirmation","Do you want to move this book to readings section?","Your bookshelf is updated :)!","The action is canceled!",()=>{
  // this.props.addReadingBooks(event);
  // this.props.removeBooks(event);
  // });
}
updateFinishedBooks(event){
  this.props.addFinishedBooks(event);
 this.props.removeBooks(event);
  document.getElementsByClassName('title')[0].click();
// this.forceUpdate();
  // promptAlert("Confirmation","Do you want to move this book to finished section?","Your bookshelf is updated :)!","The action is canceled!",()=>{     this.props.addFinishedBooks(event);
  // this.props.removeBooks(event);
  // });
}
updateWannaReadBooks(event){
  this.props.addWannaReadBooks(event);
  this.props.removeBooks(event);
  document.getElementsByClassName('title')[0].click();
  //this.forceUpdate();
  // promptAlert("Confirmation","Do you want to move this book to wishlist section?","Your bookshelf is updated :)!","The action is canceled!",()=>{         this.props.addWannaReadBooks(event);
  // this.props.removeBooks(event);
  // });
}
removeBooks(event){
  this.props.removeBooks(event);
  document.getElementsByClassName('title')[0].click();
  // this.forceUpdate();
  // promptAlert("Are you sure?","This action can't be reverted!","The book is deleted!","Your book is still safe!",()=>{
  // this.props.removeBooks(event);
  // });
}
render(){
  const group = this.props.group,
        name = this.props.name,
        showDrop = this.showDrop.bind(this);
        this.updateReadingBooks = this.updateReadingBooks.bind(this);
        this.updateFinishedBooks = this.updateFinishedBooks.bind(this);
        this.updateWannaReadBooks = this.updateWannaReadBooks.bind(this);        this.removeBooks = this.removeBooks.bind(this);
  return (
    <div className="settings">
      <i className="fa fa-cog cog" aria-hidden="true" onClick={showDrop} />
      {this.state.showDrop?
        <div data-group={group}>
       {group=="reading"?"":<p data-group={group} data-target="reading" name={name} onClick={this.updateReadingBooks}>Move to reading</p>}
       {group=="finished"?"":<p data-group={group} data-target="finished" name={name} onClick={this.updateFinishedBooks}>Move to finished</p>}
       {group=="wannaRead"?"":<p data-group={group} data-target="finished" name={name} onClick={this.updateWannaReadBooks}>Move to wannaRead</p>}
       <p data-group={group} name={name} onClick={this.removeBooks}>Delete</p>
      </div>:""}
    </div>
    );
    }
}

// 將刪除修改的action creators綁上去
const mapDispatchToProps_Settings = (dispatch)=>{
  return Redux.bindActionCreators({
    addReadingBooks: action_addReadingBooks,
    addFinishedBooks: action_addFinishedBooks,
    addWannaReadBooks: action_addWannaReadBooks,
    removeBooks: action_removeBooks
  },dispatch);
}

Settings = ReactRedux.connect(null,mapDispatchToProps_Settings)(Settings);      
      
let BookInfo = (props)=>{ 
  const info = props.currentBook.volumeInfo;
  let cover = props.currentBook.volumeInfo.imageLinks?
      { backgroundImage: 'url(' + props.currentBook.volumeInfo.imageLinks.thumbnail + ')'
}:null,
  group=props.match.params.group,
  eltoshow;
  if(group){
    switch(group){
      case "reading":
        eltoshow = <p className="status">You're reading this book</p>;
        break;
      case "finished":
        eltoshow = <p className="status">You've finished reading this book</p>;
        break;
      case "wannaRead":
        eltoshow = <p className="status">This book's in your wishlist</p>;
        break;
    }
  }else{
    const isbn = props.match.params.isbn;
    if(!eltoshow){
    props.readingBooks.forEach((book)=>{
 if(isbn==book.volumeInfo.industryIdentifiers[0].identifier){
      eltoshow = <p className="status">You're reading this book</p>;
      }
    });
    if(!eltoshow){
    props.finishedBooks.forEach((book)=>{
 if(isbn==book.volumeInfo.industryIdentifiers[0].identifier){
      eltoshow = <p className="status">You've finished reading this book</p>;
      }
    });
      if(!eltoshow){
    props.wannaReadBooks.forEach((book)=>{
 if(isbn==book.volumeInfo.industryIdentifiers[0].identifier){
      eltoshow = <p className="status">This book's in your wishlist</p>;
      }
    });
        if(!eltoshow){
          eltoshow=(<Menu 
       addReadingBooks={props.addReadingBooks}
       addFinishedBooks={props.addFinishedBooks}
       addWannaReadBooks={props.addWannaReadBooks}
       />);
          }// end if(!eltoshow) 4
        }// end if(!eltoshow) 3
      }// end if(!eltoshow) 2
    }// end if(!eltoshow) 1
  }
  
  return (<div className="bookInfo">
      <div className="bookInfo_top">
        <div className="bookinfo_book">
          <div className="bookInfo_cover" style={cover}></div>
        </div>
        <div className="bookinfo_detail">
          <p className="bookinfo_title">{info.title}</p>
          <p className="bookinfo_subtitle">{info.subtitle}</p>
          {eltoshow}
          <p>{info.authors?info.authors.join(","):null}</p>
          <p>分類: 
{info.categories?info.categories.join(","):null}
          </p>
          <p>{info.industryIdentifiers?"ISBN: "+info.industryIdentifiers[0].identifier:""}</p>
          <p>{info.language?"語言: "+info.language:""}</p>
          <p>{info.pageCount?"頁數: "+info.pageCount:null}</p>
          <p>{info.publishedDate?"出版日期: "+info.publishedDate:null}</p>
          <p>{info.publisher?"出版商: "+info.publisher:null}</p>
          {info.previewLink?(<p><a href={info.previewLink}>試閱連結</a></p>):null}
          <p></p>
          <p></p>
        </div>
      </div>
      <div className="bookinfo_summary"> Description:
      <br/>
 {props.currentBook.volumeInfo.description}
      </div>
    </div>)
}

const BookInfo_mapStateToProps=(state)=>{
  return {currentBook: state.currentBook,
          readingBooks: state.readingBooks,
          finishedBooks: state.finishedBooks,
          wannaReadBooks: state.wannaReadBooks
         };
}
const mapDispatchToProps_bookInfo = (dispatch)=>{
  return Redux.bindActionCreators({
    addReadingBooks: action_addReadingBooks,
    addFinishedBooks: action_addFinishedBooks,
    addWannaReadBooks: action_addWannaReadBooks
  },dispatch);
}

BookInfo = ReactRedux.connect(BookInfo_mapStateToProps,mapDispatchToProps_bookInfo)(BookInfo);
      
class Menu extends Component{
  constructor(props){
    super(props);
    this.state={showMenu:false,
               style: {transformOrigin:"50% 50%",
                      transform: "rotate(0deg)"} };
  }
  showMenu(){
    let flag = this.state.showMenu;
  this.setState({showMenu:!(flag)});
  if(!(flag)){
    this.setState({style: {
      transformOrigin:"50% 50%",
      transform: "rotate(45deg)"}});
  }else{
    this.setState({style: {
      transformOrigin:"50% 50%",
      transform: "rotate(0deg)"}
    });
  }
}
  render(){
    const props = this.props;
    this.showMenu = this.showMenu.bind(this);
    
    return(
      <div className="menu">
        <CSSTransitionGroup
          transitionName="menu"
          transitionEnterTimeout={1000}
          transitionLeaveTimeout={1000}
        >
        {this.state.showMenu?<div>
          <p onClick={props.addReadingBooks} data-group="current">I'm reading this!</p>
          <p onClick={props.addFinishedBooks} data-group="current">I've read this!</p>
          <p onClick={props.addWannaReadBooks} data-group="current">I want to read this!</p></div>:""}
        </CSSTransitionGroup>
          <i className="fa fa-plus plus" aria-hidden="true" style={this.state.style} onClick={this.showMenu}></i>
      </div>
    );
}}

const Nav = (props)=>{
  return (
    <div className="nav">
      <Link to="/bookshelf" className="title">
        <i className="fa fa-book" aria-hidden="true"></i>
        BookShelf</Link>
      <Link to="/" className="search">Search
        <i className="fa fa-search" aria-hidden="true"></i>
      </Link>
    </div>
  );
}

// function thunkMiddleware(store) {
//   return function(next) {
//     return function(action) {
//       if (typeof action === "function") {
//         return action(store.dispatch, store.getState);
//       } else {
//         return next(action);
//       }
//     }
//   }
// }

      
const Provider = ReactRedux.Provider;
const store = Redux.createStore(rootReducer,Redux.applyMiddleware(thunk));
      
store.subscribe(()=>{
  saveStore(store.getState());
 });

class App extends Component{
  constructor(props){
    super(props);
    window.addEventListener("resize",
    debounce(()=>{this.forceUpdate();},500)
    );
  }
  reset(){
    window.scrollTo(0,0);
    window.onscroll = null;
    alert("reset");
  }
  render(){
    this.reset = this.reset.bind(this);
    return (
      <Provider store={store}>
        <div>
          <HashRouter>
            <div>
            <Nav/>
            <Switch>
              <Route path="/:group/:isbn" component={BookInfo} onChange={this.reset}/>
              <Route path="/bookshelf" component={ShelfPage} onChange={this.reset}/>
              <Route path="/:isbn" component={BookInfo} onChange={this.reset}/>
              <Route path="/" component={SearchPage} onChange={this.reset}/>
            </Switch>
            </div>
          </HashRouter>
        </div>
      </Provider>    
    );
  }
}

render(<App/>,document.querySelector("#container"));


const promptAlert = (title,text,success,cancel,fn)=>{
sweetAlert({
  title: title,
  text: text,
  type: 'warning',
  showCancelButton: true,
  confirmButtonColor: '#3085d6',
  cancelButtonColor: '#d33',
  confirmButtonText: 'Yes, do it!',
  cancelButtonText: 'No, cancel!',
  confirmButtonClass: 'btn btn-success',
  cancelButtonClass: 'btn btn-danger',
  buttonsStyling: false
}).then(function () {
  
  fn();

  sweetAlert(
    'Success!',
    success,
    'success'
  )
}, function (dismiss) {
  // dismiss can be 'cancel', 'overlay',
  // 'close', and 'timer'
  if (dismiss === 'cancel') {
    sweetAlert(
      'Cancelled',
      cancel,
      'error'
    )
  }
})        
        
}
      
function loadStore(propName){
  try{
    let store = localStorage.getItem("books");
    if(store===null) return [];
    store = JSON.parse(store);
    switch(propName){
      case "readingBooks":
        return store.readingBooks;
      case "finishedBooks":
        return store.finishedBooks;
      case "wannaReadBooks":
        return store.wannaReadBooks;
      default:
        return [];
    }
  }catch(err){
    return [];
  }
}

function saveStore(state){
  let books =  {readingBooks: state.readingBooks,
      finishedBooks: state.finishedBooks,
      wannaReadBooks: state.wannaReadBooks};
  books = JSON.stringify(books);
  try{
    localStorage.setItem("books",
     books
    );
  }catch(err){
  }
}


 function debounce(func, wait, immediate) {
 var timeout;
 return function() {
 var context = this, args = arguments;
 var later = function() {timeout = null;if (!immediate) func.apply(context, args);};
 var callNow = immediate && !timeout;
 clearTimeout(timeout);
 timeout = setTimeout(later, wait);
 if (callNow) func.apply(context, args);
   };
 };